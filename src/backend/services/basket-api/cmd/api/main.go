package main

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/Shopify/sarama"
	"github.com/jurabek/basket.api/cmd/config"
	"github.com/jurabek/basket.api/internal/database"
	"github.com/jurabek/basket.api/internal/docs"
	grpcsvc "github.com/jurabek/basket.api/internal/grpc"
	"github.com/jurabek/basket.api/internal/handlers"
	"github.com/jurabek/basket.api/internal/middlewares"
	pbv1 "github.com/jurabek/basket.api/pb/v1"
	"github.com/redis/go-redis/v9"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/reflection"

	"github.com/redis/go-redis/extra/redisotel/v9"
	"go.opentelemetry.io/contrib/instrumentation/github.com/Shopify/sarama/otelsarama"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
	"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.17.0"

	"github.com/jurabek/basket.api/internal/repositories"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"

	"github.com/gin-gonic/gin"

	// swagger embed files	// docs is generated by Swag CLI, you have to import it.
	ginSwagger "github.com/Jurabek/gin-swagger" // gin-swagger middleware
	swaggerFiles "github.com/swaggo/files"      // swagger embed files
)

var (
	GitCommit string
	Version   string
)

//	@title			Basket API
//	@version		1.0
//	@description	This is a rest api for basket which saves items to redis server
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	API Support
//	@contact.url	http://www.swagger.io/support
//	@contact.email	support@swagger.io

//	@license.name	Apache 2.0
//	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html
func main() {
	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
	gin.SetMode(gin.DebugMode)

	basePath, _ := os.LookupEnv("BASE_PATH")
	docs.SwaggerInfo.BasePath = basePath

	tp, err := initTracer()
	if err != nil {
		log.Fatal().Err(err)
	}
	defer func() {
		if err := tp.Shutdown(context.Background()); err != nil {
			log.Printf("Error shutting down tracer provider: %v", err)
		}
	}()

	handleSigterm()
	router := gin.Default()
	router.Use(middlewares.RequestMiddleware())
	router.Use(otelgin.Middleware("basket-api"))

	cfg := config.Init()

	redisClient, err := initRedis(cfg.RedisHost)
	if err != nil {
		fmt.Print(err)
	}

	p, err := sarama.NewSyncProducer([]string{cfg.KafkaBroker}, nil)
	if err != nil {
		log.Fatal().Err(err).Msg("new producer failed!")
	}

	tracedProducer := otelsarama.WrapSyncProducer(nil, p)
	defer tracedProducer.Close()

	basketRepository := repositories.NewRedisBasketRepository(redisClient)
	basketHandler := handlers.NewBasketHandler(basketRepository)

	go grpcServer(grpcsvc.NewCartGrpcService(basketRepository))

	api := router.Group(basePath + "/api/v1/")
	{
		basket := api.Group("items")
		{
			basket.GET(":id", basketHandler.Get)
			basket.POST("", basketHandler.Create)
			basket.DELETE(":id", basketHandler.Delete)
		}
	}

	// Home page should be redirected to swagger page
	router.GET(basePath+"/", func(c *gin.Context) {
		c.Redirect(http.StatusMovedPermanently, basePath+"/swagger/index.html")
	})

	router.GET(basePath+"/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler,
		func(c *ginSwagger.Config) {
			c.URL = basePath + "/swagger/doc.json"
		}))

	_ = router.Run()
}

func grpcServer(svc pbv1.CartServiceServer) {
	lis, err := net.Listen("tcp", ":8081")
	if err != nil {
		log.Fatal().Err(err)
	}

	server := grpc.NewServer(
		grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()),
		grpc.StreamInterceptor(otelgrpc.StreamServerInterceptor()),
	)
	reflection.Register(server)

	pbv1.RegisterCartServiceServer(server, svc)

	log.Info().Msg("Starting gRPC server on port 8081...")
	if err := server.Serve(lis); err != nil {
		log.Fatal().Err(err)
	}
}

func handleSigterm() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGTERM, os.Kill, os.Interrupt)
	go func() {
		<-c
		time.Sleep(10 * time.Second)
		os.Exit(0)
	}()
}

func initTracer() (*sdktrace.TracerProvider, error) {
	ctx := context.Background()

	res, err := resource.New(ctx,
		resource.WithAttributes(
			// the service name used to display traces in backends
			semconv.ServiceName("basket-api"),
		),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// If the OpenTelemetry Collector is running on a local cluster (minikube or
	// microk8s), it should be accessible through the NodePort service at the
	// `localhost:30080` endpoint. Otherwise, replace `localhost` with the
	// endpoint of your cluster. If you run the app inside k8s, then you can
	// probably connect directly to the service through dns.
	ctx, cancel := context.WithTimeout(ctx, time.Second)
	defer cancel()

	otelExportEndpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	if otelExportEndpoint == "" {
		otelExportEndpoint = "localhost:4317"
	}
	conn, err := grpc.DialContext(ctx, otelExportEndpoint,
		// Note the use of insecure transport here. TLS is recommended in production.
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create gRPC connection to collector: %w", err)
	}

	// Set up a trace exporter
	traceExporter, err := otlptracegrpc.New(ctx, otlptracegrpc.WithGRPCConn(conn))
	if err != nil {
		return nil, fmt.Errorf("failed to create trace exporter: %w", err)
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithSampler(sdktrace.AlwaysSample()),
		sdktrace.WithResource(res),
		sdktrace.WithBatcher(traceExporter),
	)
	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))
	return tp, nil
}

func initRedis(redisHost string) (*redis.Client, error) {
	if redisHost == "" {
		redisHost = ":6379"
	}
	redisClient := redis.NewClient(&redis.Options{
		Addr: redisHost,
	})

	// Enable tracing instrumentation.
	if err := redisotel.InstrumentTracing(redisClient); err != nil {
		log.Fatal().Err(err)
	}

	// Enable metrics instrumentation.
	if err := redisotel.InstrumentMetrics(redisClient); err != nil {
		log.Fatal().Err(err)
	}

	err := database.HealthCheck(context.Background(), redisClient)
	return redisClient, err
}
